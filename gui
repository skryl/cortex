#!/usr/bin/env ruby
require 'bundler/setup'
require 'benchmark'
Bundler.require(:default)

require_relative 'htm/htm'

PATTERN = [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
           [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]]

CORTEX = HTM.new(pattern: PATTERN)

CURSED_CONFIG = {
  keybindings: {
    ' ' => lambda { step },
    'f' => lambda { step(10) },
    'F' => lambda { step(100) },
    'm' => lambda { toggle_container(:menu) },
    't' => lambda { toggle_container(:head) },
    ')' => lambda { show_child!(find_container 0) },
    '!' => lambda { show_child!(find_container 1) },
    '@' => lambda { show_child!(find_container 2) },
    '#' => lambda { show_child!(find_container 3) },
    '$' => lambda { show_child!(find_container 4) },
    '%' => lambda { show_child!(find_container 5) },
    '^' => lambda { show_child!(find_container 6) },
    '&' => lambda { show_child!(find_container 7) },
    '*' => lambda { show_child!(find_container 8) },
    '(' => lambda { show_child!(find_container 9) }
  },

  variables: {
    htm:      -> { CORTEX },
    columns:  -> { htm.columns },
    synapses: -> { htm.columns.flat_map(&:synapses)},
    segments: -> { htm.cells.map(&:segments) },
    cells:    -> { htm.cells },

    step: ->(n=1) {
      Benchmark.realtime { n.times { htm.step } }
    },

    toggle_container: ->(container) {
      container = find_container(container)
      container.visible? ?
        container.not_visible! :
        container.visible!
    },

    hidden_children_for_container: -> {
      in_focus.hidden_children.map.with_index{ |c,i| "[#{i}](#{c.id})" }.join(' ')
    },

    styles: {
      head:        { border: true, height: 5, bc: :blue, fg: :yellow },
      body:        { border: false, exclusive: true },
      menu:        { border: true, bc: :blue, fg: :yellow, height: 4 },

      screen:      { visible: false, border: false, flow: :horizontal },
      left_panel:  { border: false },
      right_panel: { border: false },
      instrument:  { border: true }
    },
  },

  layout: [
    { id: :head, class: :head, name: 'Cortex 0.01', content: -> {
      { status: {
          screen:          nil,
          cycles:          htm.cycles,
          step_time:       0.0,
          inputs:          htm.num_inputs,
          columns:         htm.num_columns,
          cells:           htm.num_cells },
        columns: {
          input_size:      Column::INPUT_SIZE,
          min_overlap:     ProximalDendrite::MIN_OVERLAP,
          iradius:         htm.inhibition_radius,
          des_local_act:   Column::DESIRED_LOCAL_ACTIVITY,
          active_columns:  htm.active_columns.count,
          col_act_ratio:   htm.column_activity_ratio },
        cells: {
          learning_cells:  htm.learning_cells.count,
          predicted_cells: htm.predicted_cells.count,
          active_cells:    htm.active_cells.count,
          cell_act_ratio:  htm.cell_activity_ratio } }}
    },

    { id: :body, class: :body, layout: [
      { id: 0, class: :screen, visible: true, layout: [
        { id: :activity, class: :left_panel, layout: [

          {id: :activity, class: :instrument, fg: :red, bg: :blue,
           streams: [-> { columns.map { |c| c.active? ? '#' : ''}} ]},

          {id: :raw_overlap, class: :instrument, fg: :yellow, bg: :green,
           streams: [-> { columns.map { |c| c.raw_overlap }} ]},

          {id: :inputs, class: :instrument, fg: :red, bg: :green,
           streams: [-> { columns.map { |c| c.active? ? '#' : '' }} ]}
        ]},
        { id: :overlap, class: :right_panel, layout: [

          {id: :overlap, class: :instrument, fg: :green, bg: :yellow, cell_size: 5,
           streams: [-> { columns.map { |c| c.overlap }} ]},

          {id: :min_local_activity, class: :instrument, fg: :blue, bg: :green, cell_size: 5,
           streams: [-> { columns.map { |c| c.min_local_activity }} ]}
        ]}
      ]},

      { id: 1, class: :screen, layout: [
        { id: :counts, class: :left_panel, layout: [
          {id: :active_count, class: :instrument, fg: :yellow, bg: :green, cell_size: 3,
           streams: [-> { columns.map { |c| c.active_count }} ]},

          {id: :overlap_count, class: :instrument, fg: :yellow, bg: :green, cell_size: 3,
           streams: [-> { columns.map { |c| c.overlap_count }} ]},

          {id: :boost, class: :instrument, fg: :red, bg: :yellow, cell_size: 6,
           streams: [-> { columns.map { |c| c.boost }} ]}
        ]},
        { id: :boost, class: :right_panel, layout: [
          {id: :active_duty_cycle, class: :instrument, fg: :green, bg: :yellow, cell_size: 4,
           streams: [-> { columns.map { |c| c.active_duty_cycle }} ]},

          {id: :overlap_duty_cycle, class: :instrument, fg: :green, bg: :yellow, cell_size: 4,
           streams: [-> { columns.map { |c| c.overlap_duty_cycle }} ]},

          {id: :min_duty_cycle, class: :instrument, fg: :green, bg: :yellow, cell_size: 6,
           streams: [-> { columns.map { |c| c.min_duty_cycle }} ]}

        ]}
      ]},

      { id: 2, class: :screen, layout: [
        { id: :synapse_indices, class: :left_panel, layout: [
          {id: :synapse_indices, class: :instrument, fg: :green, bg: :yellow, grid: :minimal,
           streams: [-> { synapses.map { |s| s.input.index }},
                     -> { synapses.map { |s| s.active? ? '#' : '' }} ]}
        ]},
        { id: :synapse_permancence, class: :right_panel, layout: [
          {id: :synapse_perm, class: :instrument, fg: :green, bg: :yellow, grid: :minimal,
           streams: [-> { synapses.map { |s| perm = (s.permanence * 100).to_i; perm > 49 ? '#' : perm }},
                     -> { synapses.map { |s| s.active? ? '#' : '' }} ]}
        ]}
      ]},

      { id: 3, class: :screen, layout: [
        { id: :cells, class: :left_panel, layout: [
          {id: :segments, class: :instrument, fg: :yellow, bg: :blue, grid: :minimal, cell_size: 4,
           streams: [-> { segments.map { |s| s.synapses.count }} ]}
        ]}
      ]},

      { id: 4, class: :screen, layout: [
        { id: :cells, class: :right_panel, layout: [
          {id: :learning, class: :instrument, fg: :green, bg: :blue,
           streams: [-> { cells.map { |c| c.learning? ? '#' : ''}} ]},
          {id: :segments, class: :instrument, fg: :yellow, bg: :blue,
           streams: [-> { cells.map { |c| c.segments.count }} ]}
        ]}
      ]},

      { id: 5, class: :screen, layout: [
        { id: :cells, class: :left_panel, layout: [
          {id: :activity, class: :instrument, fg: :red, bg: :blue,
           streams: [-> { cells.map { |c| c.active? ? '#' : ''}} ]},
          {id: :predictions, class: :instrument, fg: :magenta, bg: :blue,
           streams: [-> { cells.map { |c| c.prev_predicted? ? '#' : ''}} ]}
        ]}
      ]}
    ]},

    { id: :menu, class: :menu, content: -> { "HIDDEN: #{hidden_children_for_container}" },
      keybindings: {
       '0' => lambda { show_hidden_child!(0) },
       '1' => lambda { show_hidden_child!(1) },
       '2' => lambda { show_hidden_child!(2) },
       '3' => lambda { show_hidden_child!(3) },
       '4' => lambda { show_hidden_child!(4) },
       '5' => lambda { show_hidden_child!(5) },
       '6' => lambda { show_hidden_child!(6) },
       '7' => lambda { show_hidden_child!(7) },
       '8' => lambda { show_hidden_child!(8) },
       '9' => lambda { show_hidden_child!(9) }} }
  ]}

Cursed::WM.new(CURSED_CONFIG).run

# PATTERN = [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
#            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
#            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
#            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]

# PATTERN = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
#            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
#            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
#            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
#            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]

# RubyProf.start
# result = RubyProf.stop

# PRINTERS = [
#   RubyProf::FlatPrinter,
#   RubyProf::FlatPrinterWithLineNumbers,
#   RubyProf::GraphPrinter,
#   RubyProf::GraphHtmlPrinter
# ]
#
# PRINTERS.each.with_index do |p, i|
#   File.open("report#{i}.txt", 'w') { |f| p.new(result).print(f, min_percent: 2) }
# end

# printer = RubyProf::MultiPrinter.new(result)
# printer.print(path: '.', profile: 'profile')
